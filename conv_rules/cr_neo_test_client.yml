# ====================================================
# EXAMPLE PROTOCOL 2
# Author: Alberto Dominguez
# ====================================================
name: "test-conv"
ext_conn_group: "test_client" # empty, or 'default' ==> no group (only one file valid without group)
enable_use: yes

operation:
  mode: "client" # server (default)/client
  ip: "seclopedevega.local" # In server mode: Origin IP from external connections, empty means any. In client mode: what ip to connect (o domain)
  use_ip6: no # yes/no (default)
  port: 8080
  encrypted: no # yes/no (default).
  tls_client_authentication: no # yes/no (default). This enable TLS authentication
  transport_protocol: "udp" # TCP(default)/UDP
  encoding: "utf-8" # A value of the following list: 'utf-8' (default), 'utf-16', 'utf-32', 'ascii'
  close_socket_connection_after_replying: no # yes/no(default) [Aplicable for tcp or dtls]
  enable_rule_triggered_closing_socket_connection:
    yes # yes/no(default) [Only aplicable for tcp or dtls] It closes the socket but it not ends
    # the logical conection when the mode of close after answering is not enable and a rule with the 'closing'
    # field is enable
  use_port_for_connection_identification: no # yes/no(default). Recommendation: Disable this if the tcp connection will be closed after answering
  interaction_timeout: 360 # seconds, 0 (or negatives values) means not timeout
  connection_queue: 5 # number of unaccepted connections that the system will allow before refusing new connections (default = 5).
  max_input_size: 1024 # Max number of bytes accepted as input (default = 1024)
  max_concurrent_connection:
    5 # Max number of concurrent connections allowed (default = 5), in client mode it will be the number of connections
    # established with the target.
  conversation_use_only_first_hit:
    yes # yes/no(default) This means that only the first rule detected if several conversation rules are applicable.
    # The rule with the smallest ID is the one executed
  memory_update_when: rule_detected # One of the following: "rule_detected", "rule_executed"(default).
  memory_variables_multi_ext_connector_enable: yes # yes/no(default). To enable the use of Redis server to share memory variables between external connectors
  multi_ext_connector_memory_overwrite_during_init: yes # yes/no(default). To overwrite exisisting memory variables in Redis during the initialization phase

  # This adds a session ID for each connection once created (server mode), and this is used to recognise the connection
  # the external connector will check this ID for each request before executing any rule to identify the connection
  # In client mode, it will use the key, the separator, and the end value to identify the session id, to keep the conversation:
  # SESSION_KEY//SEPARATOR//SESSION_VALUE = KEY+KEY_VALUE_SEPARATOR+{session_value}+END_VALUE
  # The session key and session value must be added in the messages sent by the external connector using this notation: {{SESSION_KEY}}, {{SESSION_VALUE}}
  session:
    enable: yes # yes/no(default)
    key: "id"
    key_value_separator: ":"
    end_value: ";" # character after the session value (if not provided, it matches the end of string ~EOF)
    autogenerated: #  for server mode
      enable: yes # yes(default)/no
      number_characters: 20 # default 12
      # One of the following: "numbers", "hex_lower", "hex_upper", "alphanumeric_upper", "alphanumeric_lower"(default), "alphanumeric_mix",
      # "alphanumeric_and_symbols_upper", "alphanumeric_and_symbols_lower", "alphanumeric_and_symbols_mix"
      characters_type: "alphanumeric_lower"
    update:
      enable: yes # yes/no(default)
      when: rule_detected # One of the following: "rule_detected", "rule_executed(default)"

# ---------------------------------------------------------------------
# Execution memory
# ---------------------------------------------------------------------
memory_variables:
  # list of memory variables
  # use one the following types: "int", "float", "string"(default), "bool"
  # 'name' is CASE SENSITIVE, and should be unique
  # these variables can be added in the messages sent by the external connector using this notation: {{VAR_NAME}}

  multi_extconn_level: # Shared for all external connectors. If already existing, the variable is not modified in its initialization phase
    - name: multi_client_ended
      default_value: False
      type: false

  global_level: # Shared for all connections in the same external connector
    - name: "global_memory"
      default_value: "empty"
      type: string

  connection_level: # Each connection / session get a different set of variables
    - name: "counter"
      default_value: 0
      type: int

    - name: temp_session
      default_value: empty
      type: string

# ---------------------------------------------------------------------
# Execution rules
# ---------------------------------------------------------------------
# The conversation rules set. The default mode is 'sync', other values are 'async' and 'hybrid'. In the 'async' case
# the regex field is not used, the next rule to execute is the one mentioned in the 'rule_trigger'. If that rule is
# the number '0', it means the 'async' rule should be executed asynchronously after the connection start. For 'hybrid'
# ones, it will be executed either the regex is detected (and memory conditions are met), or in a asyncrhonous way.
# When several regex rules are detected, they are executed in the order they are described in the conversation rules file.
# The regex and the response can be added using base64, to avoid issues at loading time to avoid having issues with
# some characters, thought "escaping characters" is allowed in this file via '\'
conversation:
  greetings:
    name: "GREETINGS"
    value: "Hello! I'm the client! C{{counter}}\n"
    enable: yes # yes/no (default)

  custom_rules: # list of rules
    rules:
      - id: 1
        mode: "sync"
        regex: "S1"
        response: "C{{counter}};{{session_key}}:{{session_value}};\n"

        capturing_data:
          enable: yes # yes/no(default)
          captures:
            - regex: "(?<=id:)(.*?)(?=;)"
              mem_var_name: "temp_session"
        memory:
          updates:
            - var_name: "counter"
              value: "1"
        session_update:
          enable: yes # yes/no (default)
          memory_variable: "temp_session"

      - id: 2
        mode: "sync"
        regex: "S2"
        memory:
          updates:
            - var_name: "counter"
              value: "2"
        response: "C{{counter}};{{session_key}}:{{session_value}};\n"
        reconnect_before_rule_execution:
          yes # yes/no(default) [Only aplicable for tcp transport protocol or DTLS]. It reconnects the socket before execute the rule.
          # The field' enable_rule_triggered_closing_socket_connection'
          # should be enable to use this field

      - id: 3
        mode: "sync"
        regex: "S3"
        memory:
          updates:
            - var_name: "counter"
              value: "3"
        response: "C{{counter}};{{session_key}}:{{session_value}};\n"

      - id: 4
        mode: "sync"
        regex: "S5"
        trigger:
          - rule_id: 5 # Next rule to execute
        delay: 3 # seconds to wait until execute the rule descibed in the 'rule trigger' field

      - id: 5
        mode: "async"
        memory:
          updates:
            - var_name: "counter"
              value: "4"
            - var_name: "multi_client_ended"
              value: True
        response: "C{{counter}};{{session_key}}:{{session_value}};\n"

      - id: 6
        mode: "sync"
        regex: "sayonara baby 0.0"
        ending_rule: yes
