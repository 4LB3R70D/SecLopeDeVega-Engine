# ====================================================
# EXAMPLE PROTOCOL
# Author: Alberto Dominguez
# ====================================================
name: test_neo2
enable_use: yes # yes/no (default). This enables the use of this conversation rules
# ext_conn_group: test_neo # empty, or 'default' ==> no group (only one file valid without group)

operation:
  mode: server # server (default)/client
  ip: 127.0.0.1 # In server mode: Origin IP from external connections, empty means any. In client mode: what ip to connect (o domain)
  use_ip6: no # yes/no (default)
  port: 8888
  encrypted: no # yes/no (default). TLS/DTLS
  tls_client_authentication: no # yes/no (default). This enable TLS authentication
  transport_protocol: "TCP" # TCP(default)/UDP
  encoding: "utf-8" # A value of the following list: 'utf-8' (default), 'utf-16', 'utf-32', 'ascii'
  close_socket_connection_after_replying: no # yes/no(default) [Aplicable for tcp or dtls]
  enable_rule_triggered_closing_socket_connection:
    yes # yes/no(default) [Only aplicable for tcp or dtls] It closes the socket but it not ends
    # the logical conection when the mode of close after answering is not enable and a rule with the 'closing'
    # field is enable
  use_port_for_connection_identification: yes # yes/no(default). Recommendation: Disable this if the tcp connection will be closed after answering
  interaction_timeout: 600 # seconds, 0 (or negatives values) means no timeout for connections
  connection_queue: 5 # number of unaccepted connections that the system will allow before refusing new connections (default = 5)
  max_input_size: 1024 # Max number of bytes accepted as input (default = 1024)
  max_concurrent_connection:
    5 # Max number of concurrent connections allowed (default = 5), in client mode it will be the number of connections
    # established with the target
  conversation_use_only_first_hit:
    no # yes/no(default) This means that only the first rule detected if several conversation rules are applicable.
    # The rule with the smallest ID is the one executed
  memory_update_when: rule_detected # One of the following: "rule_detected", "rule_executed"(default).
  memory_operations_when: rule_detected # One of the following: "rule_detected", "rule_executed"(default). (Before session update and custom functions)
  report_memory: yes # yes/no(default). Report the status of the memory for each external activity generated (This adds many entries in the database)
  encode_b64_memory_reported: yes # yes/no(default). Encode b64 the memroy variables content at the time of reporting memory
  memory_variables_multi_ext_connector_enable: yes # yes/no(default). To enable the use of Redis server to share memory variables between external connectors
  multi_ext_connector_memory_overwrite_during_init: yes # yes/no(default). To overwrite exisisting memory variables in Redis during the initialization phase
  execution_delay: 3 # s
  alert_all_flag: yes

  # Custom Functions
  # 1 - Custom function preprocessor to be executed for any input before trying to detect any rule.
  # If empty or not present, it means this functionality is disabled.
  # It alwys gets the raw input as parameter and and other variables defined in the field 'additional_input' (if present),
  # and returns a variable that is the input processed by the function
  # and other variables defined in the field 'additional_output' (if present)
  # The function has to return the processed input as the first value, and after, all additional values to be saved in memory variables
  custom_function_preprocessor:
    enable: yes
    name: neo_preprocessor # Custom function to be executed for any input before trying to detect any rule.
    # additional
    input:
      - input_counter
    # additional
    output:
      - input_counter

  # 2 - Custom function postprocessor to be executed for after any rule.
  # If empty or not present, it means this functionality is disabled.
  # It alwys gets the result of the rule execution as input and and other variables defined in the field 'additional_input' (if present)
  # The function has to return the processed output as the first value, and after, all additional values to be saved in memory variables
  custom_function_postprocessor:
    enable: yes
    name: neo_postprocessor
    # additional
    input:
      - output_counter
    # additional
    output:
      - output_counter

  # 3 - Custom functions to be executed for rules
  custom_functions_when: rule_detected # One of the following: "rule_detected", "rule_executed"(default). (After memory update and before session updates)

  # This adds a session ID for each connection once created (server mode), and this is used to recognise the connection
  # the external connector will check this ID for each request before executing any rule to identify the connection
  # In client mode, it will use the key, the separator, and the end value to identify the session id, to keep the conversation:
  # SESSION_KEY//SEPARATOR//SESSION_VALUE = KEY+KEY_VALUE_SEPARATOR+{session_value}+END_VALUE
  # The session key and session value must be added in the messages sent by the external connector using this notation: {{SESSION_KEY}}, {{SESSION_VALUE}}
  session:
    enable: yes # yes/no(default)
    key: id
    key_value_separator: ":"
    end_value: "" # character after the session value (if not present, it will try to limit the session value via a 'space' character, 'brake line' character, or 'end' character)
    autogenerated: #  for server mode
      enable: yes # yes(default)/no
      number_characters: 20 # default 12
      # One of the following: "numbers", "hex_lower", "hex_upper", "alphanumeric_upper", "alphanumeric_lower"(default), "alphanumeric_mix",
      # "alphanumeric_and_symbols_upper", "alphanumeric_and_symbols_lower", "alphanumeric_and_symbols_mix"
      characters_type: alphanumeric_and_symbols_lower
    update:
      enable: yes # yes/no(default)
      when: rule_detected # One of the following: "rule_detected", "rule_executed(default)"

  # Conditional execution: The external connector only starts execution in the context of having multi external connector memory variables, when one or several of them
  # has a set of defined values. It can get the IP and port for the execution from some meory variables as well. These memory variables can be different for those declared
  # to be used in the simulation
  conditional_execution:
    enable: no # yes/no(default)
    conditions:
      - var_name: order_66
        value: True
      - var_name: order_67
        value: False
    mem_var_ip: ip_mem_var
    mem_var_port: port_mem_var

# ---------------------------------------------------------------------
# Execution memory
# ---------------------------------------------------------------------
memory_variables:
  # list of memory variables
  # use one the following types: "int", "float", "string"(default), "bool"
  # 'name' is CASE SENSITIVE, and should be unique
  # these variables can be added in the messages sent by the external connector using this notation: {{VAR_NAME}}
  import:
  - path: /conv_rules/test_neo_mem_vars.yml
    is_relative: yes

# ---------------------------------------------------------------------
# Execution rules
# ---------------------------------------------------------------------
# The conversation rules set. The default mode is 'sync', other values are 'async' and 'hybrid'. In the 'async' case
# the regex field is not used, the next rules to execute are the ones declared in the 'trigger' block. If that rule is
# the number '0', it means the 'async' rule should be executed asynchronously after the connection start. For 'hybrid'
# ones, it will be executed either the regex is detected (and memory conditions are met), or in a asyncrhonous way.
# When several regex rules are detected, they are executed in the order they are described in the conversation rules file.
# The regex and the response can be added using base64, to avoid issues at loading time to avoid having issues with
# some characters, thought "escaping characters" is allowed in this file via '\'
conversation:
  greetings:
    value:
      "\nlope-> Welcome to Sec Lope De Vega! Your session id is: {{session_key}}:{{session_value}};\n
      This is the 'greetings' message, it is executed when a new connection is established\n\n"
    enable: yes # yes/no (default)

  custom_rules: # list of rules
    rules:
      - id: 1
        mode: sync
        regex: x1x
        response: "\nlope-> Hola! Your are connected from the ip:{{IP}} and port:{{PORT}}\n\n"

      - id: 101
        mode: sync
        regex: x1x
        response:
          "\nlope-> Hello there! I am a second rule that is listening for the same input of the rule number '1'.\n
          I am only executed if the configuration allows several rules interacting for the same input!\n\n"

      # ========================================================================================
      # ASYNC RULES
      # ========================================================================================

      - id: 2
        mode: async
        response: "\nlope-> This is an async rule executed at least 3 seconds later after the connection is established!\n\n"
        beginning_async_rule: yes # yes/no (default)
        beginning_async_delay: 3 # seconds to wait until being executed

      - id: 3
        mode: sync
        regex: x2x
        response:
          "\nlope-> Rules can be asyncrhonous and they are triggered by any rule.\n
          This was is triggering a set of 3 async rules using asynchronous rules\n\n"
        trigger:
          - rule_id: 4 # Next rule to execute
            delay: 0.5 # sec

      - id: 4
        mode: async
        response: "\nlope-> Hello, my name is IÃ±igo Montoya.\n\n"
        trigger:
          - rule_id: 5 # Next rule to executein_wrkr.cnv_rules.ExtOperation.ConditionalExecution
            delay: 0.5 # sec

      - id: 5
        mode: async
        response: "\nlope-> You killed my father.\n\n"
        trigger:
          - rule_id: 6 # Next rule to execute
            delay: 0.5 # sec

      - id: 6
        mode: async
        response: "\nlope-> Prepare to die.\n\n"

      - id: 7
        regex: x3x
        mode: sync
        response:
          "\nlope-> There are rules that are hybrid. They can be executed synchronously or asynchronously.\n
          This rule (number 7) is triggering an hybrid rule (number 8)\n\n"
        trigger:
          - rule_id: 8 # Next rule to execute

      - id: 8
        regex: x4x
        mode: hybrid
        response: "\nlope-> This is an hybrid rule, triggered asynchronously by the rule '7' or when the input is 'x4x' (synchronously)\n\n"

      - id: 9
        regex: x5x
        mode: sync
        response: ""
        trigger:
          - rule_id: 10 # Next rule to execute

      - id: 10
        mode: async
        response: "\nlope-> \n
          \nlope-> Sometimes, synchronous rules have nothing to response, but they are 'executed' as well.\n
          This rule (number 10) for instance is an async rule triggered by the sync rule that\n
          is applicable for the input 'x5x' (number 9)\n\n"

      # ========================================================================================
      # MEMORY VARIABLES: GENERAL + CONNECTION LEVEL
      # ========================================================================================
      - id: 11
        regex: x6x
        mode: sync
        response:
          "\nlope-> You can use the memory variables anytime by using 2x'{'+ variable_name + 2x'}' to add them in the response\n
          For example, in this connection the memory variables are:\n
          - 'conn_memory_string': {{conn_memory_string}}\n
          - 'conn_memory_float': {{conn_memory_float}}\n
          - 'conn_memory_int': {{conn_memory_int}}\n
          - 'conn_memory_bool': {{conn_memory_bool}}\n
          And these memory variables are different for each connection of the external connector\n\n"

      - id: 12
        regex: x7x
        mode: sync
        response:
          "\nlope-> Asynchronous rules can have nothing to response, but they can do other things like updating memory values.\n
          Use again 'x6x' to check it\n\n"
        trigger:
          - rule_id: 13 # Next rule to execute

      - id: 13
        mode: async
        memory:
          updates:
            - var_name: conn_memory_string
              value: "Async rule '12' executed!"
            - var_name: conn_memory_float
              value: 5.34
            - var_name: conn_memory_int
              value: 25
            - var_name: conn_memory_bool
              value: True

      - id: 14
        regex: x8x
        mode: sync
        response:
          "\nlope-> Any rule can modify the memory variables, synchronous or asynchronous one.\n
          This one is reseting all connection level memory variables to the default values.\n
          Use again 'x6x' to check it. The memory variables can be updated when the rule is \n
          either executed or detected, depending on the configuration\n\n"
        memory:
          updates:
            - var_name: conn_memory_string
              value: "perro"
            - var_name: conn_memory_float
              value: 2.71
            - var_name: conn_memory_int
              value: 11
            - var_name: conn_memory_bool
              value: False

      - id: 15
        regex: x9x
        mode: sync
        response:
          "\nlope-> The memory variables allows to add conditions (memory variable should have a specific value) for rule execution as well. \n
          For instance, this rule is changing the value of the memory variable 'conn_memory_string' to 'dog'. \n
          The next rule (number 16, input 'x10x') will only execute if this rule has been executed previously \n
          (content of 'conn_memory_string' is 'dog' and not 'perro'). If those conditions are not fulfilled\n
          then the 'default' rule is executed (if enabled)\n\n"
        memory:
          updates:
            - var_name: conn_memory_string
              value: "dog"

      - id: 16
        regex: x10x
        mode: sync
        response:
          "\nlope-> Since the memory variable 'conn_memory_string' has the content: '{{conn_memory_string}}', \n
          this rule has been executed!. Doing so, other memory variable is modified: 'conn_memory_int' now is '5'.\n
          Rules can update memory variables at the same time they have conditions for execution.\n
          The next rule needs two conditions for execution: 'conn_memory_string' == 'dog' and 'conn_memory_int'=='5'.\n
          Check it by using 'x11x'(rule number 17)\n\n"
        memory:
          conditions:
            - var_name: conn_memory_string
              value: "dog"
          updates:
            - var_name: conn_memory_int
              value: 5

      - id: 17
        regex: x11x
        mode: sync
        response: "\nlope-> Rule 17 executed! Any rule can have from 1 to 'n' conditions to satisfy for allowing its execution\n\n"
        memory:
          conditions:
            - var_name: conn_memory_string
              value: "dog"
            - var_name: conn_memory_int
              value: 5

      - id: 18
        regex: x12x
        mode: sync
        response:
          "\nlope-> Conditional execution also affects asynchronous rules too. This rule is triggering an async rule\n
          that will only execute if the memory variable 'conn_memory_string'=='perro'\n
          (you should reset the content using 'x8x' to modify it and see the effects)\n\n"
        trigger:
          - rule_id: 19

      - id: 19
        mode: async
        response: "\nlope-> I am the rule number '19'! executed asynchronously only if 'conn_memory_string'=='perro'\n\n"
        memory:
          conditions:
            - var_name: conn_memory_string
              value: "perro"

      - id: 20
        regex: x13x
        mode: sync
        response:
          "\nlope-> Memory variables can be used to capture information from the input. This one tries to capture data for the connection memory variables.\n
          For the 'conn_memory_string' add the new content between 's-' and '-s', like this example: 's-mouse-s'\n
          For the 'conn_memory_float' add the new content between 'f-' and '-f', like this example: 'f-10.07-f'\n
          For the 'conn_memory_int' add the new content between 'i-' and '-i', like this example: 'i--34-i'\n
          For the 'conn_memory_bool' add the new content between 'b-' and '-b', like this example: 'b-true-b'\n
          Use the input 'x13x' and any of the previous estructures to modify the memory variables\n
          For instance: 'x13x s-mouse-s f-10.07-f i--34-i b-true-b'\n
          You can use the input 'x6x' to see the changes, and this rule for adding different data.\n
          If the capture RegEx does not detect anything (no hits),\n
          no data is loaded into the variables and they should contain the previous value.\n
          This one of capturing data is for the RegEx used in this example, you can add any RegEx for capturing data\n\n"
        capturing_data:
          enable: yes
          captures:
            - regex: (?<=s-)(.*?)(?=-s)
              mem_var_name: conn_memory_string
            - regex: (?<=f-)[-+]?[0-9]*\.?[0-9]+.(?=-f)
              mem_var_name: conn_memory_float
            - regex: (?<=i-)-*[0-9]+(?=-i)
              mem_var_name: conn_memory_int
            - regex: (?<=b-)([tT]rue)*([ff]alse)*(?=-b)
              mem_var_name: conn_memory_bool

      - id: 21
        regex: x14x
        mode: sync
        response:
          "\nlope-> Memory variables can be defined and initialized using fixed values, or autogenerated.\n
          For example, in this connection these memory variables are autogenerated:\n
          - 'another_token': {{another_token}} (6 char length, alphanumeric mixing lowercase and uppercase letters)\n
          - 'random_float': {{random_float}} (value between '0' and '1')\n
          - 'random_int': {{random_int}} (value between '0' and '100')\n
          - 'random_bool': {{random_bool}}
          \n\n"

      - id: 22
        regex: x15x
        mode: sync
        response:
          "\nlope-> We have seen that rules can trigger other rules depending on some conditions (set of memory variables)\n
          with specific values. However, you can have a kind of switch control flow mechanism for using one rule (or set of rules)\n
          or others depending on some set of conditions. In this case, depending on the value of 'conn_memory_string', different rules\n
          are triggered (you can modify the content of that memory variable using the input 'x13x s-XXXX-s', where XXXX is the content to add).\n
          In this case, the values expected are:\n
          - chicken => it triggers a rule for drawing a chicken (this options also requires that 'conn_memory_int' should be '5')\n
          - monkey => it triggers a rule for drawing a monkey\n
          - any other content => it triggers a rule for drawing a pig\n
          \n\n"

        # Switch for executing some async (or hybrid) rules depending on conditions. E.g., ff memory variable 'AAAA' has the value 'X' (value field), or has the same content
        # of the memory variable 'BBB', then execute the async Rule 'N'. In case no option fits, use the async rule of the default field (if present and greater than 0)
        async_switch:
          options:
            # first option or 'case' wit a list of conditions to satisfy
            - conditions:
                - var_name: conn_memory_string
                  value: chicken
                - var_name: conn_memory_int
                  value: 5
              # if conditions are satisfied, then a set of async (or hybrid) rules to execute
              rules:
                - rule_id: 22
                  delay: 1

            # second option or 'case'
            - conditions:
                - var_name: conn_memory_string
                  value: monkey
              rules:
                - rule_id: 23
                  delay: 1

          default:
            # set of async ruls to execute if no 'case' statement is applicable
            - rule_id: 24
              delay: 1

      - id: 23
        mode: async
        response: "
          \nlope-> \n
          .      ,~.\n
          .   ,-'__ `-,\n
          .   {,-'  `. }              ,')\n
          .  ,( a )   `-.__         ,',')~,\n
          . <=.) (         `-.__,==' ' ' '}\n
          .   (   )                      /\n
          .    `-'\\   ,                  )\n
          .        | \\        `~.      /\n
          .         \\   `._       \\    /\n
          .          \\     `._____,'   /\n
          .           `-.            ,'\n
          .              `-.      ,-'\n
          .                 `~~~~'\n
          .                  //_||\n
          .               __//--'/`          hjw from ascii-art.de\n
          .              ,--'/`  '\n
          .                 '
          \n\n"

      - id: 24
        mode: async
        response: "
          \nlope-> \n
          .     w  c(..)o   (\n
          .      \\__(-)    __)\n
          .         /\\   (\n
          .        /(_)___)\n
          .        w /|\n
          .        | \\\n
          ejm97    m  m\n
          from asciiart.eu\n\n"

      - id: 25
        mode: async
        response: "
          \nlope-> \n
          .   _____\n
          ^..^     \\9\n
          (oo)_____/\n
          .  WW  WW\n
          from asciiart.eu\n\n"

      - id: 26
        regex: x16x
        mode: sync
        response:
          "\nlope-> For conditional executions and switch information flow control mechanism, you can compare variables to check if the have the same value.\n
          This rule triggers an async rule if the 'conn_memory_int' variable has the same content of the memory variable 'random_int'; and \n
          'conn_memory_float' has the same content of 'random_float'. Modify the content of 'conn_memory_int' to match 'random_int', \n
          and the content of 'conn_memory_float' to match 'random_float'. You can do it by using the input 'x13x f-YYYY-f i-XXXX-i',\n
          where 'XXXX' is the new value for the int, and 'YYYY' for the float. You can check the content of 'random_int' and 'random_float' by using 'x14x'
          \n\n"
        trigger:
          - rule_id: 27

      - id: 27
        mode: async
        response: "\nlope-> I am the rule number '26'! executed asynchronously only if 'conn_memory_int'=='random_int' and 'conn_memory_float'=='random_float' \n\n"
        memory:
          conditions:
            - var_name: conn_memory_int
              reference_variable: random_int
            - var_name: conn_memory_float
              reference_variable: random_float

      # ========================================================================================
      # MEMORY VARIABLES: GLOBAL LEVEL
      # ========================================================================================
      - id: 28
        regex: x17x
        mode: sync
        response:
          "\nlope-> The variables that we have seen so far at 'connection level'. This means their scope is only the connection or session where they live.\n
          However, there are other kind of variables that are shared among all different connections or sessions of one external connector: 'Global variables'\n
          For this execution of the external connector, these are the global memory variables in use:\n
          - 'global_memory_string': {{global_memory_string}}\n
          - 'global_memory_float': {{global_memory_float}}\n
          - 'global_memory_int': {{global_memory_int}}\n
          - 'global_memory_bool': {{global_memory_bool}}\n
          There are not differences for the connection level ones at the time of using them. The difference is how they are declared in the conversation rule file.\n
          \n\n"

      - id: 29
        regex: x18x
        mode: sync
        response:
          "\nlope-> Everything that we have seen is applicable for the any kind of memory variables. For instance, you can modify the values in the same way with this rule\n
          (rule number 28 - input 'x18x'):\n
          - For the 'global_memory_string' add the new content between 's-' and '-s', like this example: 's-mouse-s'\n
          - For the 'global_memory_float' add the new content between 'f-' and '-f', like this example: 'f-10.07-f'\n
          - For the 'global_memory_int' add the new content between 'i-' and '-i', like this example: 'i--34-i'\n
          - For the 'global_memory_bool' add the new content between 'b-' and '-b', like this example: 'b-true-b'\n
          Use the input 'x17x' to see the changes, and this rule for adding different data. If the capture RegEx does not detect anything (no hits),\n
          no data is loaded into the variables and they should contain the previous value\n\n"
        capturing_data:
          enable: yes
          captures:
            - regex: (?<=s-)(.*?)(?=-s)
              mem_var_name: global_memory_string
            - regex: (?<=f-)[-+]?[0-9]*\.?[0-9]+.(?=-f)
              mem_var_name: global_memory_float
            - regex: (?<=i-)-*[0-9]+(?=-i)
              mem_var_name: global_memory_int
            - regex: (?<=b-)([tT]rue)*([ff]alse)*(?=-b)
              mem_var_name: global_memory_bool

      - id: 30
        regex: x19x
        mode: sync
        response:
          "\nlope-> As mentioned, you can execute conditionally rules depending on the values of the global variables. For instance, this rule trigger an async rule that is only executed\n
          if the 'global_memory_string'=='rhino'. To check the current value of that variable, use 'x17x'. To modify the value, use 'x18x s-rhino-s'\n\n"
        trigger:
          - rule_id: 31 # Next rule to execute

      - id: 31
        mode: async
        response: "\nlope-> Since 'global_memory_string'=='rhino', this async rule is successfully executed!\n\n"
        memory:
          conditions:
            - var_name: global_memory_string
              value: "rhino"

      # ========================================================================================
      # MEMORY VARIABLES: MULTI CONNECTOR LEVEL
      # ========================================================================================
      - id: 32
        regex: x20x
        mode: sync
        response:
          "\nlope-> The 'Multi connector memory variables' are those with the widest scope:\n
          They are shared among different external connectors. You can use them in the same\n
          way that you are using the rest of them, and they can be quite useful to share information among them\n
          (e.g.: session information), or conditionally execute\n
          some conversation rules in one external connector depending on what has happened in other external conenctor. \n
          In that sense, they can work really together\n
          These variables requires the use of a REDIS server to achieve this. For this execution, these are the variables:\n
          - 'multi_memory_string': {{multi_memory_string}}\n
          - 'multi_memory_float': {{multi_memory_float}}\n
          - 'multi_memory_int': {{multi_memory_int}}\n
          - 'multi_memory_bool': {{multi_memory_bool}}\n\n"

      - id: 33
        regex: x21x
        mode: sync
        response:
          "\nlope-> You can modify the multi connector memory values in the same way with this rule (rule number 32 - input 'x21x'):\n
          For the 'multi_memory_string' add the new content between 's-' and '-s', like this example: 's-mouse-s'\n
          For the 'multi_memory_float' add the new content between 'f-' and '-f', like this example: 'f-10.07-f'\n
          For the 'multi_memory_int' add the new content between 'i-' and '-i', like this example: 'i--34-i'\n
          For the 'multi_memory_bool' add the new content between 'b-' and '-b', like this example: 'b-true-b'\n
          Use the input 'x20x' to see the changes, and this rule for adding different data. \n
          If the capture RegEx does not detect anything (no hits),\n
          no data is loaded into the variables and they should contain the previous value\n\n"
        capturing_data:
          enable: yes
          captures:
            - regex: (?<=s-)(.*?)(?=-s)
              mem_var_name: multi_memory_string
            - regex: (?<=f-)[-+]?[0-9]*\.?[0-9]+.(?=-f)
              mem_var_name: multi_memory_float
            - regex: (?<=i-)-*[0-9]+(?=-i)
              mem_var_name: multi_memory_int
            - regex: (?<=b-)([tT]rue)*([ff]alse)*(?=-b)
              mem_var_name: multi_memory_bool

      - id: 34
        regex: x22x
        mode: sync
        response:
          "\nlope-> As mentioned previously, you can execute conditionally rules depending on the values of the multi connector variables as well.\n
          For instance, this rule trigger an async rule that is onlye executed\n
          if the 'multi_memory_float'=='14.14'. To check the current value of that variable, use 'x20x'. To modify the value, use 'x21x f-14.14-f'\n\n"
        trigger:
          - rule_id: 35 # Next rule to execute

      - id: 35
        mode: async
        response: "\nlope-> Since 'multi_memory_float'=='14.14', this async rule is successfully executed!\n\n"
        memory:
          conditions:
            - var_name: multi_memory_float
              value: 14.14

      # ========================================================================================
      # SESSION SUPPORT
      # ========================================================================================
      - id: 36
        regex: x23x
        mode: sync
        response:
          "\nlope-> When session support is enabled in server mode, there is a session id generated for each connection depending on the configuration.\n
          The different options supported are:'numbers', 'hex_lower', 'hex_upper', 'hex_mix', 'alphanumeric_upper', 'alphanumeric_lower'(default), 'alphanumeric_mix',\n
          'alphanumeric_and_symbols_upper', 'alphanumeric_and_symbols_lower', 'alphanumeric_and_symbols_mix'. You can check it by using\n
          2x'{' + SESSION_KEY + 2x'}' and 2x'{' + SESSION_VALUE + 2x'}' in any response.
          \nThis value is used to detect if a new request belongs to a certain connection/session in some scenarios.\n
          In the current session, the session key and value is: {{SESSION_KEY}}:{{SESSION_VALUE}};\n
          In client mode, the session ID is captured using the 'capturing' capability of the memory variables. In that sense,\n
          it works in this way: external input content ==> memory variable ==> sessiond ID. However, you can modify the session ID in other different ways.\n
          Usually, any session modification can be executed ince the rule is detected or executed, depending on the configuration.\n
          This rule is going to trigger 2 async rules to show the different ways of updating the session id\n\n"
        trigger:
          - rule_id: 37 # Next rule to execute
        delay: 1 # sec

      - id: 37
        mode: async
        trigger:
          - rule_id: 38 # Next rule to execute
        delay: 1 # sec
        response: "\nlope-> This rule is generating a new session ID according with the current configuration. The new session ID is: {{SESSION_KEY}}:{{SESSION_VALUE}};\n\n"
        session_update:
          enable: yes # yes/no (default)
          autogenerated_value: yes # yes/no (default), only used when 'memory_variable' is empty

      - id: 38
        mode: async
        response:
          "\nlope-> This rule is using a fixed value for updating the session ID, as it is defined in the corresponding rule. \n
          The new session ID is: {{SESSION_KEY}}:{{SESSION_VALUE}};\n
          As described previously, the session update can use a memory variable. \n
          You can use the same rule to update the memory variable and then, the session id,\n
          or you can do in different rules at different times. \n
          For instance, if you ure the input 'x24x g_XXXXXXX_g' (where 'XXXXXXX' is anything that you want to add: numbers and letters)\n
          this new content will be the new session id by \n
          using the memory variable 'conn_memory_string'. The memory variables are always updated before the session\n\n"
        session_update:
          enable: yes # yes/no (default)
          fixed_value: qmpzenixnructbyv1029384756

      - id: 39
        mode: sync
        regex: x24x
        response:
          "\nlope-> This rule can capture new session IDs using what is within g_XXXX_g with this input: 'x24x g_XXXX_g',\n
          where 'XXXX' is the value. Current session ID => {{SESSION_KEY}}:{{SESSION_VALUE}};\n
          (if the capturing process is successful, you will see the new values)\n\n"
        capturing_data:
          enable: yes
          captures:
            - regex: (?<=g_)(.*?)(?=_g)
              mem_var_name: conn_memory_string
        session_update:
          enable: yes # yes/no (default)
          memory_variable: conn_memory_string # memory variable to use (CASE SENSITIVE)

      # ========================================================================================
      # CUSTOM FUNCTIONS
      # ========================================================================================
      - id: 40
        mode: sync
        regex: x25x
        response:
          "\nlope-> There is support for adding your own python code via 'custom functions'. \n
          This functions can be executed when a rule is detected or executed,\n
          depending on the configuration. They use the memory variables as arguments, \n
          and the output is loaded in memory variables as well. Additionally,\n
          the ip and port of the connection can be used, as well as the external input received from the connection.\n
          Custom functions execute after memory update and before session update (provided that all are configured \n
          to be executed when the rule is detected, or when the rule is executed).\n
          There is a special option that is adding a 'preprocessor', that is a custom function executed in  \n
          all functions before doing anything. The next rule\n
          (input 'x26x' - rule 40) will call a custom modify that modifies the global variables to add the \n
          input as 'global_memory_string', it will add '1.5' to the current\n
          value of 'global_memory_float', it will add '5' to the current value of 'global_memory_int'; \n
          and it will invert the value of 'global_memory_bool'.\n
          To can check the current values before calling the next rule using 'x17x', calling the 'x26x'; \n
          and later on, reuse the input 'x17x' again\n\n"

      - id: 41
        mode: sync
        regex: x26x
        response:
          "\nlope-> New values of the global memory variables in use after the execution the custom function:\n
          - 'global_memory_string': {{global_memory_string}}\n
          - 'global_memory_float': {{global_memory_float}}\n
          - 'global_memory_int': {{global_memory_int}}\n
          - 'global_memory_bool': {{global_memory_bool}}\n
          However, the 'global_memory_string' is different from the original input added. \n
          The reason is because there is a custom function working as preprocessor\n
          that adds a 'prepocessor_check' string at the end of any input received\n\n"
        custom_function:
          enable: yes
          name: neo_test
          input:
            - EXT_IN
            - global_memory_float
            - global_memory_int
            - global_memory_bool
          output:
            - global_memory_string
            - global_memory_float
            - global_memory_int
            - global_memory_bool

      - id: 42
        mode: sync
        regex: x27x
        response:
          "\nlope-> The preprocessor and the postprocessor functions are custom functions to be executed in any input and output respectively.\n
          They can get memory variables as additional parameters, and returns parameters to be added in memory variables.\n
          In this example, the preprocessor add a sufix to any input and it updates a counter of how many inputs have been received so far.\n
          The postprocessor is counting how many replies has been done so far. \n
          Both works in the same way, they get the corresponding counter as input, add 1, and then it returns it.\n
          Apart from returning the corresponding input/output\n
          Current values of the currents:\n
          - 'input_counter': {{input_counter}} (first connection counts as input)\n
          - 'output_counter': {{output_counter}}
          \n\n"
        reconnect_before_rule_execution: yes

      # ========================================================================================
      # RECONNECTION, CLOSING CONECTION SOCKET & ENDING CONNECTION
      # ========================================================================================
      - id: 43
        mode: sync
        regex: x28x
        response:
          "\nlope-> This is a rule that closes the connection and reconnects again before executing the rule. This feature works when the operation mode is 'client',\n
          and the response should contain the session id: {{SESSION_KEY}}:{{SESSION_VALUE}}; to be used for identifying the connection again after the reconnection.\n\n"
        reconnect_before_rule_execution: yes

      - id: 44
        mode: sync
        regex: x29x
        response:
          "\nlope-> This is a rule that closes the connection, but not ends it. It means the physical connection is closed (the socket), but not logically.\n
          This feature works when the operation mode is 'server' and the attribute 'enable_rule_triggered_closing_socket_connection' is enabled;\n
          and it closes the connection as needed (in contrast of the feature to close the connection after any response).\n
          Then, the client should reconnect and provide the corresponding session ID to go on with the active logic connection\n\n"
        closing_connection: yes

      - id: 45
        mode: sync
        regex_b64: yes # yes/no (default)
        regex: eDMweA==
        response_b64: yes # yes/no (default)
        response: "XG5sb3BlLT4gQ29udmVyc2F0aW9uIHJ1bGVzIGNhbiBoYXZlIFJlZ0V4IGluIGI2NCBmb3JtYXQsIGFzIHdlbGwgYXMgdGhlIGNvcnJlc3BvbmRpbmcgYW5zd2VyLCBsaWtlIHRoaXMgb25lIChpZiBlbmFibGVkKVxuXG4="

      - id: 46
        mode: sync
        regex: x31x
        response: "\nlope-> This is the ending rule, and it closes and ends the connection. Therefore, the basic conversation rule 'ending' is executed (if enabled)\n\n"
        ending_rule: yes

      # ========================================================================================
      # ASYNC LOOP & FORK
      # ========================================================================================
      - id: 102
        mode: sync
        regex: n1n
        response: "\nlope-> This rule creates an async loop.\n
          It calls an async rule every second to tic as a clock while the memory variable 'conn_memory_string'= 'clock' \n\n"
        async_loop:
          loop:
            conditions:
              - var_name: conn_memory_string
                value: "clock"
            rules:
              - rule_id: 103
                delay: 1

      - id: 103
        mode: async
        response: "\nlope-> TIC...\n\n"

      - id: 104
        mode: sync
        regex: n2n
        response:
          "\nlope-> This rule starts a new external connector instance, but since it is using the same\n
          configuration file and the same port, it cannot work (and then, it will shutdown)\n\n"
        fork:
          enable: yes
          new_id: "Broken"

    import:
    - path: /conv_rules/test_neo_rules_groups.yml
      is_relative: yes
   
  # to be executed if an input is not applicable to any conversation rule
  default:
    value: "\nlope-> No rule described for the input, so this is the default rule\n\n"
    enable: yes # yes/no (default)

  # to be executed if an empty input is received
  empty:
    value: "\nlope-> No input content detected, so this rule is executed when a new input is received but there is nothing within it\n\n"
    enable: yes # yes/no (default)

  timeout:
    value: "\nlope-> The connection has been timed out! That's why this rule is executed\n\n"
    enable: yes # yes/no (default)

  ending:
    value: "\nlope-> The connection has ended as expected, so this is the rule for the connection end: sayonara baby!\n\n"
    enable: yes # yes/no (default)
