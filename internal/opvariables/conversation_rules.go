/*
Copyright 2022 The Sec Lope De Vega Authors. All rights reserved.

This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this file,
You can obtain one at http://mozilla.org/MPL/2.0/.

=================================================
Sec Lope De Vega engine - engine_logger.go
=================================================
Author: Alberto Dominguez

This package contains the operation variables used in the system,
such as the configuration and the context ones. This file contains
everything related to conversation rules logic
*/

package opvariables

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strconv"

	"sec-lope-de-vega/internal/englogging"
	"sec-lope-de-vega/internal/utils"
	"gopkg.in/yaml.v3"
)

const (
	// group for 'no group' case
	ConsDefaultConversationRulesGroup = "default"

	// conversation rules files
	consConversationRulesYMLExt = ".yml"
)

// Autogeneration of session or memory variables
type AutoGenerated struct {
	Enable           bool    `yaml:"enable"`
	NumberCharacters int     `yaml:"number_characters"`
	CharactersType   string  `yaml:"characters_type"`
	MinLimitInterval float64 `yaml:"min_limit_interval"`
	MaxLimitInterval float64 `yaml:"max_limit_interval"`
}

// Memory variables (declaration)
type MemVariable struct {
	Name           string        `yaml:"name"`
	DefaultValue   string        `yaml:"default_value"`
	Type           string        `yaml:"type"`
	ToBeReported   bool          `yaml:"report"`
	AutoGeneration AutoGenerated `yaml:"autogenerated"`
}

// Memory elements of a conversation rule (use)
type MemElement struct {
	VarName           string `yaml:"var_name"`
	Value             string `yaml:"value"`
	ReferenceVariable string `yaml:"reference_variable"`
}

// triggering struct
type RuleTrigger struct {
	RuleID int `yaml:"rule_id"`
	Delay  int `yaml:"delay"`
}

// Switch async option
type RulesAndConditions struct {
	Conditions       []MemElement  `yaml:"conditions"`
	ConditionalRules []RuleTrigger `yaml:"rules"`
}

// Capturing data element of a conversation rule
type CaptElement struct {
	Regex      string `yaml:"regex"`
	MemVarName string `yaml:"mem_var_name"`
	B64Flag    string `yaml:"regex_b64"`
}

// information about the builtin memory operations or custom functions
type MemOpsStruct struct {
	Enable    bool     `yaml:"enable"`
	Name      string   `yaml:"name"`
	Operation string   `yaml:"operation"`
	Input     []string `yaml:"input"`
	Output    []string `yaml:"output"`
}

// information about when to report something
type AlertInfo struct {
	Email  bool `yaml:"email"`
	Http   bool `yaml:"http"`
	Kafka  bool `yaml:"kafka"`
	Syslog bool `yaml:"syslog"`
	All    bool `yaml:"all"`
}

// Operation variables for the external connector, external socket
type ExtOpVariables struct {
	Mode                               string       `yaml:"mode"`
	IP                                 string       `yaml:"ip"`
	Port                               int          `yaml:"port"`
	UseIP6                             bool         `yaml:"use_ip6"`
	Encrypted                          bool         `yaml:"encrypted"`
	TlsClientAuthentication            bool         `yaml:"tls_client_authentication"`
	TransportProtocol                  string       `yaml:"transport_protocol"`
	Encoding                           string       `yaml:"encoding"`
	CloseTCPConnectionAfterAnswering   bool         `yaml:"close_socket_connection_after_replying"`
	EnablesRulesCloseSocket            bool         `yaml:"enable_rule_triggered_closing_socket_connection"`
	UsePortForConnectionIdentification bool         `yaml:"use_port_for_connection_identification"`
	InteractionTimeout                 int          `yaml:"interaction_timeout"`
	ConnectionQueue                    int          `yaml:"connection_queue"`
	MaxInputSize                       int          `yaml:"max_input_size"`
	MaxConcurrentConnections           int          `yaml:"max_concurrent_connection"`
	ConversationUseOnlyFirstHit        bool         `yaml:"conversation_use_only_first_hit"`
	MemoryUpdateWhen                   string       `yaml:"memory_update_when"`
	MemoryOpsWhen                      string       `yaml:"memory_operations_when"`
	CustomFunctionPreprocessor         MemOpsStruct `yaml:"custom_function_preprocessor"`
	CustomFunctionPostprocessor        MemOpsStruct `yaml:"custom_function_postprocessor"`
	CustomFunctionsWhen                string       `yaml:"custom_functions_when"`
	ReportMemory                       bool         `yaml:"report_memory"`
	EncodeB64MemoryReported            bool         `yaml:"encode_b64_memory_reported"`
	MemVarMultiExtConnEnable           bool         `yaml:"memory_variables_multi_ext_connector_enable"`
	MultiExtConnMemOverwriteDuringInit bool         `yaml:"multi_ext_connector_memory_overwrite_during_init"`
	Delay                              int          `yaml:"execution_delay"`
	AlertAllFlag                       bool         `yaml:"alert_all_flag"`

	Session struct {
		Enable            bool   `yaml:"enable"`
		Key               string `yaml:"key"`
		KeyValueSeparator string `yaml:"key_value_separator"`
		EndValue          string `yaml:"end_value"`

		AutoGeneration AutoGenerated `yaml:"autogenerated"`

		Update struct {
			Enable bool   `yaml:"enable"`
			When   string `yaml:"when"`
		} `yaml:"update"`
	} `yaml:"session"`

	ConditionalExecution struct {
		Enable     bool         `yaml:"enable"`
		MemVarIp   string       `yaml:"mem_var_ip"`
		MemVarPort string       `yaml:"mem_var_port"`
		Conditions []MemElement `yaml:"conditions"`
	} `yaml:"conditional_execution"`
}

// A conversation rule
type Rule struct {
	Id                           int           `yaml:"id"`
	Mode                         string        `yaml:"mode"`
	Regex                        string        `yaml:"regex"`
	RegexBase64Flag              bool          `yaml:"regex_b64"`
	Response                     string        `yaml:"response"`
	ResponseBase64Flag           bool          `yaml:"response_b64"`
	Trigger                      []RuleTrigger `yaml:"trigger"`
	EndingRule                   bool          `yaml:"ending_rule"`
	ClosingConn                  bool          `yaml:"closing_connection"`
	ReconnectBeforeRuleExecution bool          `yaml:"reconnect_before_rule_execution"`
	BeginningAsyncRule           bool          `yaml:"beginning_async_rule"`
	BeginningAsyncDelay          int           `yaml:"beginning_async_delay"`
	Alert                        AlertInfo     `yaml:"alert"`

	// Data capturing to be saved in the simulation memory
	Capturing struct {
		Enable   bool          `yaml:"enable"`
		Captures []CaptElement `yaml:"captures"`
	} `yaml:"capturing_data"`

	// memory modification or conditions
	Memory struct {
		Conditions []MemElement `yaml:"conditions"`
		Updates    []MemElement `yaml:"updates"`
	} `yaml:"memory"`

	// builtin memory operations
	BuiltInMemOps MemOpsStruct `yaml:"builtin_memory_operation"`

	// custom function
	CustomFunction MemOpsStruct `yaml:"custom_function"`

	// session update
	SessionUpdate struct {
		Enable             bool   `yaml:"enable"`
		MemoryVariable     string `yaml:"memory_variable"`
		AutogeneratedValue bool   `yaml:"autogenerated_value"`
		FixedValue         string `yaml:"fixed_value"`
	} `yaml:"session_update"`

	// async switch
	AsyncSwitch struct {
		SwitchAsyncOptions []RulesAndConditions `yaml:"options"`
		DefaultAsyncRule   []RuleTrigger        `yaml:"default"`
	} `yaml:"async_switch"`

	// async loop
	AsyncLoop struct {
		Conditions       []MemElement  `yaml:"conditions"`
		ConditionalRules []struct {
			RuleID int `yaml:"rule_id"`
			Delay  int `yaml:"delay"`
			MaxNumberIterations int `yaml:"max_number_iterations"`
		}`yaml:"rules"`
	} `yaml:"async_loop"`

	// create a new external connector (fork)
	Fork struct {
		Enable            bool   `yaml:"enable"`
		Config            string `yaml:"config_file"`
		ExtConnID         string `yaml:"new_id"`
		Secret            string `yaml:"new_secret"`
		NumberOfInstances int    `yaml:"number"`
	} `yaml:"fork"`
}

// For 'greetings', 'default', 'timeout' and 'ending' rules
type BasicRule struct {
	Name    string    `yaml:"name"`
	Value   string    `yaml:"value"`
	B64Flag bool      `yaml:"b64_flag"`
	Enable  bool      `yaml:"enable"`
	Alert   AlertInfo `yaml:"alert"`
}

// Groups of Rules
type GroupOfRules struct {
	Id              string       `yaml:"id"`
	Regex           string       `yaml:"regex"`
	RegexBase64Flag bool         `yaml:"regex_b64"`
	Rules           []Rule       `yaml:"rules"`
	MemConditions   []MemElement `yaml:"memory_conditions"`
}

// Struct for importing auxiliary files (memory declaration and rules) of a conversation rule file
type FileImport struct {
	Path       string `yaml:"path"`
	IsRelative bool   `yaml:"is_relative"`
}

// Declaration of Memory Variables struct
type MemoryVariablesDeclaration struct {
	MultiExtConnLevel []MemVariable `yaml:"multi_extconn_level"`
	GlobalLevel       []MemVariable `yaml:"global_level"`
	ConnectionLevel   []MemVariable `yaml:"connection_level"`
	Import            []FileImport  `yaml:"import"`
}

// Custom Rules struct (defined by the operator)
type CustomRulesStruct struct {
	Rules  []Rule         `yaml:"rules"`
	Groups []GroupOfRules `yaml:"groups"`
	Import []FileImport   `yaml:"import"`
}

// conversation rules files content
type ConversationRules struct {
	Name         string `yaml:"name"`
	ExtConnGroup string `yaml:"ext_conn_group"`
	Enable       bool   `yaml:"enable_use"`

	//Operation variables
	ExtOperation ExtOpVariables `yaml:"operation"`

	// Memory variables
	MemoryVariables MemoryVariablesDeclaration `yaml:"memory_variables"`

	// Rules
	Conversation struct {
		Greetings   BasicRule         `yaml:"greetings"`
		CustomRules CustomRulesStruct `yaml:"custom_rules"`
		Default     BasicRule         `yaml:"default"`
		Empty       BasicRule         `yaml:"empty"`
		Timeout     BasicRule         `yaml:"timeout"`
		Ending      BasicRule         `yaml:"ending"`
	} `yaml:"conversation"`
}

//Method to transform the conversation rules into a JSON string
func (cr *ConversationRules) GetJSONFormat() (string, error) {
	// 'struct' ==> []bytes
	convRulesBytes, err := json.Marshal(cr)
	// []bytes ==> string
	convRulesString := string(convRulesBytes)
	return convRulesString, err
}

// ==========================================================================================
// CONVERSATION RULES LOADING FUNCTIONS
// ==========================================================================================

// Method check if a specific rule is duplicated
func (cr *ConversationRules) checkDuplicationRule(checkRule Rule) int {

	counterRuleOcurrences := 0
	for _, rule := range cr.Conversation.CustomRules.Rules {
		if checkRule.Id == rule.Id {
			counterRuleOcurrences++
		}
		if counterRuleOcurrences > 1 {
			break // stop the check if there is already a duplication
		}
	}

	// if there is no a duplication so far
	if !(counterRuleOcurrences > 1) {
		for _, group := range cr.Conversation.CustomRules.Groups {
			for _, rule := range group.Rules {
				if checkRule.Id == rule.Id {
					counterRuleOcurrences++
				}
				if counterRuleOcurrences > 1 {
					break // stop the check if there is already a duplication
				}
			}
			if counterRuleOcurrences > 1 {
				break // stop the check if there is already a duplication
			}
		}
	}
	return counterRuleOcurrences
}

// Method to verify that a file of conversation rules has not duplicated IDs
func (cr *ConversationRules) checkDuplicationRuleIDs() bool {

	var ok bool
	// only do the check if the conversation rules are enabled
	if cr.Enable {
		ok = true
		var counterRuleOcurrences int

		for _, checkRule := range cr.Conversation.CustomRules.Rules {
			counterRuleOcurrences = cr.checkDuplicationRule(checkRule)

			// every rule should only be once in each set of rules
			if counterRuleOcurrences > 1 {
				ok = ok && false
				englogging.WarnLog("The conversation rules: '"+cr.Name+"' has the rule ID: '"+
					strconv.Itoa(checkRule.Id)+"' duplicated, so it will not be used.", nil)
				break
			}
		}

		// If no duplication so far, check the groups
		if ok {
			for _, checkGroup := range cr.Conversation.CustomRules.Groups {
				for _, checkRule := range checkGroup.Rules {
					counterRuleOcurrences = cr.checkDuplicationRule(checkRule)

					// every rule should only be once in each set of rules
					if counterRuleOcurrences > 1 {
						ok = ok && false
						englogging.WarnLog("The conversation rules: '"+cr.Name+"' has the rule ID: '"+
							strconv.Itoa(checkRule.Id)+"' duplicated, so it will not be used.", nil)
						break
					}
				}
			}
		}
	}
	return ok
}

// Method to isValid if the load result has loaded a right file by checking values
// of some key attributes that always have content, as well as checking the 'enable' field
func (cr *ConversationRules) isValid() bool {

	ok := len(cr.ExtOperation.Mode) > 0 &&
		cr.ExtOperation.Port != 0 &&
		len(cr.ExtOperation.TransportProtocol) > 0 &&
		// is this conversation rule 'active' to be used?
		cr.Enable &&
		// all rules of the conversation section have different and unique IDs?
		cr.checkDuplicationRuleIDs()

	return ok
}

// function to know if a element in the folder of conversation rules is a yml file 
// or not
func isItAYmlFile(path string, info os.FileInfo) bool {

	englogging.DebugLog("Checking item detected: "+path, nil)

	// variable to return
	ok := true
	// temporary variable for text logs
	var textLog string
	// ITEM CHECKS:
	// - not a directory
	ok = ok && info != nil && !info.IsDir()
	textLog = fmt.Sprintf("Is it not a directory?: %s", strconv.FormatBool(ok))
	englogging.DebugLog(textLog, nil)

	// - it is a YML file?
	ok = ok && (filepath.Ext(path) == consConversationRulesYMLExt)
	textLog = fmt.Sprintf("Is it a YML file?: %s", strconv.FormatBool(ok))
	englogging.DebugLog(textLog, nil)

	return ok
}

// function to explore all conversation rules saved in the conversation rules folder
func listConversationRulesFiles(engineDir, conversationRulesPath string, isRelativePath bool) []string {

	englogging.InfoLog("Scanning conversation rules folder", nil)
	conversationRulesPathFinal := utils.RelativeToAbasolutePathIfRelative(engineDir, conversationRulesPath,
		isRelativePath)
	var ymlFiles []string
	// https://flaviocopes.com/go-list-files/
	err := filepath.Walk(conversationRulesPathFinal,
		// function called for each element within the folder under scan
		// https://golang.org/pkg/path/filepath/#WalkFunc
		func(path string, info os.FileInfo, err error) error {
			if isItAYmlFile(path, info) {
				ymlFiles = append(ymlFiles, path)
			}
			return nil
		})
	if err != nil {
		englogging.FatalLog("Error listing all conversation rules files, ending execution", err)
	}
	return ymlFiles
}

// Function to open and parse a yml file given an object to be filled
func openAndParseYmlFile(fileAbsPath string, convRulesToFill, memVarsToFill, rulesToFill bool) (bool,
	ConversationRules, MemoryVariablesDeclaration, CustomRulesStruct, error) {

	var success bool
	var filePath *os.File
	var convRules ConversationRules
	var memVarsInAuxFile MemoryVariablesDeclaration
	var rulesInAuxFile CustomRulesStruct
	var err error

	if filePath, err = os.Open(fileAbsPath); err == nil {
		defer filePath.Close()
		ymlDecoder := yaml.NewDecoder(filePath)

		if convRulesToFill {
			if err = ymlDecoder.Decode(&convRules); err == nil {
				success = true
			}
		} else if memVarsToFill {
			if err = ymlDecoder.Decode(&memVarsInAuxFile); err == nil {
				success = true
			}
		} else if rulesToFill {
			if err = ymlDecoder.Decode(&rulesInAuxFile); err == nil {
				success = true
			}
		}
	}
	return success, convRules, memVarsInAuxFile, rulesInAuxFile, err
}

// Function to import the auxiliary files for the memory variables information
func importAuxFilesForMemVars(convRules ConversationRules, engineDir string) ConversationRules {

	if len(convRules.MemoryVariables.Import) > 0 {
		var end bool
		var index int
		var success bool
		var memVarsInAuxFile MemoryVariablesDeclaration
		var err error

		for !end {
			importInfo := convRules.MemoryVariables.Import[index]
			memoryAuxFileAbsPath := utils.RelativeToAbasolutePathIfRelative(engineDir,
				importInfo.Path, importInfo.IsRelative)

			// parsing config file and put the results in the struct (object)
			if success, _, memVarsInAuxFile, _, err = openAndParseYmlFile(
				memoryAuxFileAbsPath,
				false, true, false); success {

				// add the imported content into the conversation rules master content
				if len(memVarsInAuxFile.MultiExtConnLevel) > 0 {
					convRules.MemoryVariables.MultiExtConnLevel = append(
						convRules.MemoryVariables.MultiExtConnLevel,
						memVarsInAuxFile.MultiExtConnLevel...)
				}
				if len(memVarsInAuxFile.GlobalLevel) > 0 {
					convRules.MemoryVariables.GlobalLevel = append(
						convRules.MemoryVariables.GlobalLevel,
						memVarsInAuxFile.GlobalLevel...)
				}
				if len(memVarsInAuxFile.ConnectionLevel) > 0 {
					convRules.MemoryVariables.ConnectionLevel = append(
						convRules.MemoryVariables.ConnectionLevel,
						memVarsInAuxFile.ConnectionLevel...)
				}
				if len(memVarsInAuxFile.Import) > 0 {
					// This file is importing other files as well
					convRules.MemoryVariables.Import = append(
						convRules.MemoryVariables.Import,
						memVarsInAuxFile.Import...)
				} else {
					// successful end
					end = true
				}
			} else {
				// not successful end
				end = true
			}
			// loop result
			if success {
				englogging.InfoLog("Auxiliary file: '"+memoryAuxFileAbsPath+
					"' of memory variables imported successfully for the conversation rules:'"+
					convRules.Name+"'", nil)
			} else {
				englogging.ErrorLog("Not possible to open and read the auxiliary file: '"+
					memoryAuxFileAbsPath+"' of memory variables for the conversation rules:'"+
					convRules.Name+"'", err)
			}
			if !end {
				index += 1
			}
		}
	}
	return convRules
}

// Function to import the auxiliary files for the rules information
func importAuxFilesForRules(convRules ConversationRules, engineDir string) ConversationRules {

	if len(convRules.Conversation.CustomRules.Import) > 0 {
		var end bool
		var index int
		var success bool
		var rulesInAuxFile CustomRulesStruct
		var err error

		for !end {
			importInfo := convRules.Conversation.CustomRules.Import[index]
			rulesAuxFileAbsPath := utils.RelativeToAbasolutePathIfRelative(engineDir,
				importInfo.Path,
				importInfo.IsRelative)

			// parsing config file and put the results in the struct (object)
			if success, _, _, rulesInAuxFile, err = openAndParseYmlFile(rulesAuxFileAbsPath,
				false, false, true); success {

				// add the imported content into the conversation rules master content
				if len(rulesInAuxFile.Groups) > 0 {
					rulesInAuxFile.Groups = append(rulesInAuxFile.Groups,
						rulesInAuxFile.Groups...)
				}
				if len(rulesInAuxFile.Rules) > 0 {
					rulesInAuxFile.Rules = append(rulesInAuxFile.Rules,
						rulesInAuxFile.Rules...)
				}
				if len(rulesInAuxFile.Import) > 0 {
					// This file is importing other files as well
					rulesInAuxFile.Import = append(rulesInAuxFile.Import,
						rulesInAuxFile.Import...)
				} else {
					// successful end
					end = true
				}
			} else {
				// not successful end
				end = true
			}

			// loop result
			if success {
				englogging.InfoLog("Auxiliary file: '"+rulesAuxFileAbsPath+
					"' of rules imported successfully for the conversation rules: '"+
					convRules.Name+"'", nil)
			} else {
				englogging.ErrorLog("Not possible to open and read the auxiliary file: '"+
					rulesAuxFileAbsPath+"' of rules for the conversation rules:'"+
					convRules.Name+"'", err)
			}
			if !end {
				index += 1
			}
		}
	}
	return convRules
}

// Function to load auxliary files decleared in the master file (conversation rules files) and import them
func importAuxFiles(convRules ConversationRules, engineDir string) ConversationRules {

	// Import memory variables declared in auxiliary files
	convRules = importAuxFilesForMemVars(convRules, engineDir)
	// Import rules and groups declared in auxiliary files
	convRules = importAuxFilesForRules(convRules, engineDir)
	return convRules
}

// function to load the conversation variables from the configuration file
func LoadConversationRules(engineDir, conversationRulesPath string, relativePath bool) []*ConversationRules {

	englogging.InfoLog("Loading conversation rules files", nil)

	// listing conversation rule files in the folder
	convRulesFiles := listConversationRulesFiles(engineDir, conversationRulesPath, relativePath)
	numberElementsFound := len(convRulesFiles)
	textLog := fmt.Sprintf("Found %s yml files", strconv.Itoa(numberElementsFound))
	englogging.InfoLog(textLog, nil)

	// if not yml to load ==> end execution
	if numberElementsFound == 0 {
		englogging.FatalLog("No yml files detected, ending execution", nil)
	}
	// list to return (go slice)
	listConversationRules := make([]*ConversationRules, 0)

	// for each element in the list
	for _, crFilePath := range convRulesFiles {

		// open the conversation rule file
		if success, convRules, _, _, err := openAndParseYmlFile(crFilePath, true, false, false); success {
			// import additional auxiliary files (if any) and build the final conversation rule 'object'
			convRules = importAuxFiles(convRules, engineDir)
			if !convRules.isValid() {
				englogging.InfoLog("Not valid or disabled conversation rule file: "+crFilePath, nil)
			} else {
				listConversationRules = append(listConversationRules, &convRules)
				englogging.DebugLog("Conversation rules file: "+crFilePath+" loaded correctly", nil)
			}
		} else {
			englogging.ErrorLog("Not possible to open and read the yml file: '"+crFilePath+"' ", err)
		}
	}
	return listConversationRules
}
